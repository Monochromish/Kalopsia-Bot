const {
  MessageActionRow,
  MessageButton,
  MessageSelectMenu,
  MessageEmbed,
} = require('discord.js');

const Profile = require('../../Models/Profile');
const { createProfile } = require('../../Structures/Utils');
require('dotenv').config();
const Config = require('../../Config');
const request = require('../../Structures/Request');
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');
const adapter = new FileSync('db.json');
const db = low(adapter);
const { reward } = require('../../Config');

module.exports = {
  name: 'vote',
  description: 'NFT Ìà¨Ìëú ÏãúÏûë/Ï¢ÖÎ£å!',
  options: [
    {
      name: 'option',
      description:
        'start(Ìà¨ÌëúÏãúÏûë) / end(Ìà¨ÌëúÏ¢ÖÎ£å) / result(Ìà¨ÌëúÍ≤∞Í≥º Í≥ÑÏÇ∞) / clear(Ïù¥Ï†Ñ Ìà¨ÌëúÍ∏∞Î°ù ÏÇ≠Ï†ú)',
      required: true,
      type: 'STRING',
      choices: [
        { name: 'start', value: 'poll_start' },
        { name: 'end', value: 'poll_end' },
        { name: 'result', value: 'poll_result' },
        {
          name: 'clear',
          value: 'poll_clear',
          description: 'Ïù¥Ï†Ñ Ìà¨Ìëú Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌï©ÎãàÎã§.',
        },
      ],
    },
  ],
  permissions: 'ADMINISTRATOR',
  type: 'COMMAND',
  run: async ({ interaction, options, bot, guild }) => {
    // console.log(interaction);
    if (!interaction.isCommand()) return;

    // filter : Î≤ÑÌäºÏóê ÏßÄÏ†ïÎêú customIdÎßå message collectorÍ∞Ä ÎèôÏûëÌï† Ïàò ÏûàÍ≤å Ìï®
    // const filter = (i) => {
    //   return i.user.id === interaction.user.id;
    // };

    // collector : discord.js component eventÎ•º ÏàòÏßëÌïòÎäî Í∞ùÏ≤¥
    const collector = await interaction.channel.createMessageComponentCollector(
      {
        // filter,
        // time: 60 * 3000, // Î™áÏ¥àÎèôÏïà Î∞òÏùëÌï† Ïàò ÏûàÎäîÏßÄ, msÎã®ÏúÑÎùºÏÑú 3Ï¥àÎ©¥ 3000ÏúºÎ°ú ÏûÖÎ†•
      }
    );
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////START///////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    if (interaction.options.get('option').value === 'poll_start') {
      await interaction.reply('Loading...(Working on it.)');
      const messages = await interaction.channel.messages.fetch();

      //Ìà¨ÌëúÍ∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏùÑÍ≤ΩÏö∞, ÏïÑÏßÅ ÏãúÏûëÌïòÏßÄ ÏïäÏïòÏùÑ Í≤ΩÏö∞ÏóêÎäî GoogleSheetÏóêÏÑú Í∞íÏùÑ fetch
      //Í∑∏ Ïô∏(Í∏∞ÌÉÄ Î™ÖÎ†πÏñ¥Ïãú Îç∞Ïù¥ÌÑ∞, ÎπÑÏ†ïÏÉÅ Ï¢ÖÎ£å ÌõÑ Ïû¨ÏãúÏûë)Îäî lowdbÏóêÏÑú Í∏ÅÏñ¥Ïò®Îã§.

      //lowdbÏóêÏÑú ÌòÑÏû¨ Ìà¨Ìëú ÏÉÅÌÉúÎ•º ÏùΩÏñ¥Ïò¥
      const isVoting = db.get('voteStatus').value().isVoting;
      console.log('db::isVoting', isVoting);
      //isVoting: false - Ï†ïÏÉÅ / true - ÎπÑÏ†ïÏÉÅ
      if (
        isVoting &&
        db.get('bluechipList').value()?.length > 0 &&
        db.get('risingList').value()?.length > 0
      ) {
        //ÎπÑÏ†ïÏÉÅÏ¢ÖÎ£åÎêú voting
        //fetch lowdb
      } else {
        //Ï†ïÏÉÅÏ¢ÖÎ£åÎêú voting
        //fetch googleSheet
        const apiKey = process.env.GOOGLE_ACCESS_TOKEN;
        const spreadsheetId = Config.google.databaseKey;
        const sheetName = ['general', 'bluechip', 'rising'];
        try {
          const response = await request({
            method: 'GET',
            url: `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName[0]}?key=${apiKey}`,
            json: true,
            maskResponse: ({ Data, ...rest }, mask) => ({
              ...rest,
              Data: mask,
            }),
          });
          db.get('voteStatus')
            .assign({
              isVoting: true,
              voteId: response.values[1][0],
              voteTitle: response.values[1][1],
            })
            .write();
        } catch (error) {
          console.error(error);
        }

        try {
          const response = await request({
            method: 'GET',
            url: `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName[1]}?key=${apiKey}`,
            json: true,
            maskResponse: ({ Data, ...rest }, mask) => ({
              ...rest,
              Data: mask,
            }),
          });
          const bluechipList = [];
          response.values.slice(1).forEach((e) => {
            bluechipList.push({ name: e[0], id: e[1] });
          });
          db.get('bluechipList').remove().write();
          db.get('bluechipList').assign(bluechipList).write();
        } catch (error) {
          console.error(error);
        }
        try {
          const response = await request({
            method: 'GET',
            url: `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${sheetName[2]}?key=${apiKey}`,
            json: true,
            maskResponse: ({ Data, ...rest }, mask) => ({
              ...rest,
              Data: mask,
            }),
          });
          const risingList = [];
          response.values.slice(1).forEach((e) => {
            risingList.push({ name: e[0], id: e[1] });
          });
          db.get('risingList').remove().write();
          db.get('risingList').assign(risingList).write();
        } catch (error) {
          console.error(error);
        }
      }
      // const bluechipList = db.get('bluechipList').value();
      // const risingList = db.get('risingList').value();
      const buttons = [
        // Í∞Å Î≤ÑÌäºÏùÑ Î∞∞Ïó¥(array) ÏûêÎ£åÍµ¨Ï°∞Î°ú ÎßåÎì§Ïñ¥Ïöî
        {
          customId: 'bluechipButton',
          label: 'Bluechip Ìà¨ÌëúÌïòÍ∏∞',
          style: 'PRIMARY',
        },
        {
          customId: 'risingButton',
          label: 'Rising Ìà¨ÌëúÌïòÍ∏∞',
          style: 'PRIMARY',
        },
      ];

      // console.log({ messages });
      messages.forEach((value, key, object) => {
        //Ïù¥Ï†Ñ Ìà¨Ìëú Î™ÖÎ†πÏñ¥ Î©îÏãúÏßÄÎ•º Îã§ ÏÇ≠Ï†ú
        try {
          if (value.interaction.commandName === 'vote')
            value.edit({ components: [] });
        } catch (error) {}
      });
      const buttonRow = new MessageActionRow().addComponents(
        // buttons arrayÎ•º ÌïòÎÇòÏî© ÏùΩÏñ¥ÏÑú Î≤ÑÌäºÏùÑ ÎßåÎì§Í≤å Îê©ÎãàÎã§
        buttons.map((button) => {
          return new MessageButton()
            .setCustomId(button.customId)
            .setLabel(button.label)
            .setStyle(button.style);
        })
      );

      const voteStatus = db.get('voteStatus').value();
      const embed = new MessageEmbed().setTitle(
        `
        ‚òùÔ∏è${voteStatus.voteTitle}üöÄ

        Choose your Favorite NFT!
        1. Bluechip
        2. Rising
        `
      );

      // ÎîîÏä§ÏΩîÎìúÏóê Ï∂úÎ†•ÌïòÎäî ÏΩîÎìú
      // Î∞îÎ°ú reply ÌïòÎ©¥ ÌÉÄÏù¥Î∞ç Ïù¥ÏäàÎñÑÎ¨∏Ïóê Ïò§Î•òÍ∞Ä ÎÇúÎã§.
      const wait = (timeToDelay) =>
        new Promise((resolve) => setTimeout(resolve, timeToDelay)); //Ïù¥ÏôÄ Í∞ôÏù¥ ÏÑ†Ïñ∏ ÌõÑ
      await wait(2000);
      await interaction.editReply({
        content: 'NFT Vote Message',
        components: [buttonRow],
        embeds: [embed],
      });
    }
    ///////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////END////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    else if (interaction.options.get('option').value === 'poll_end') {
      collector.stop();

      const messages = await interaction.channel.messages.fetch();
      // console.log({ messages });
      messages.forEach((value, key, object) => {
        //Ïù¥Ï†Ñ Ìà¨Ìëú Î™ÖÎ†πÏñ¥ Î©îÏãúÏßÄÎ•º Îã§ ÏÇ≠Ï†ú
        try {
          if (value.interaction.commandName === 'vote')
            value.edit({ components: [] });
        } catch (error) {}
      });

      await interaction.reply(`Ìà¨ÌëúÍ∞Ä Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.`);
      db.get('voteStatus')
        .assign({
          isVoting: false,
        })
        .write();
    }
    ///////////////////////////////////////////////////////////////////////////
    //////////////////////////////////RESULT///////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    else if (interaction.options.get('option').value === 'poll_result') {
      await interaction.reply('Loading...(Working on it.)');
      const voteStatus = db.get('voteStatus').value();
      const voteId = voteStatus.voteId;

      const fetchVotingData = db
        .get('voteUser')
        .value()
        .filter((e) => e.voteId === voteId);
      const votingData = Array.isArray(fetchVotingData)
        ? fetchVotingData
        : [fetchVotingData];
      const bluechipCountObject = votingData.reduce((r, e) => {
        // if (e.bluechipChoice && e.bluechipChoice.length > 0) {
        r[`${e.bluechipChoice}`] = (r[`${e.bluechipChoice}`] || 0) + 1;
        // }
        return r;
      }, {});
      const bluechipCountArray = Object.entries(bluechipCountObject).map(
        (e) => {
          return { name: e[0], count: e[1] };
        }
      );
      bluechipCountArray.sort((a, b) => b.count - a.count);

      const risingCountObject = votingData.reduce((r, e) => {
        // if (e.risingChoice && e.risingChoice.length > 0) {
        r[`${e.risingChoice}`] = (r[`${e.risingChoice}`] || 0) + 1;
        // }
        return r;
      }, {});
      const risingCountArray = Object.entries(risingCountObject).map((e) => {
        return { name: e[0], count: e[1] };
      });
      risingCountArray.sort((a, b) => b.count - a.count);

      const bluechipRank3 = bluechipCountArray.slice(0, 3);
      const risingRank3 = risingCountArray.slice(0, 3);
      console.log({ voteId, bluechipRank3, risingRank3 });

      const embed = new MessageEmbed().setTitle(
        `
        ‚òùÔ∏è${voteStatus.voteTitle}üöÄ
        <RANK RESULT> 

        - Bluechip RANK
        1Ô∏è‚É£ : ${bluechipRank3[0]?.name}
        2Ô∏è‚É£ : ${bluechipRank3[1]?.name}
        3Ô∏è‚É£ : ${bluechipRank3[2]?.name}

        - Rising RANK
        1Ô∏è‚É£ : ${risingRank3[0]?.name}
        2Ô∏è‚É£ : ${risingRank3[1]?.name}
        3Ô∏è‚É£ : ${risingRank3[2]?.name}
        `
      );
      await interaction.editReply({
        content: 'NFT Vote Rank Result',
        embeds: [embed],
      });

      // Îû≠ÌÇπ rewardÏßÄÍ∏â //
      const voteRewarded = db.get('voteRewarded').value();
      if (voteRewarded.includes(voteId)) {
        //Ïù¥ÎØ∏ ÏßÄÍ∏â
      } else {
        //ÎØ∏ÏßÄÍ∏â
        fetchVotingData.forEach(async (e) => {
          let profile = await Profile.find({
            UserID: e.id,
            GuildID: guild.id,
          });
          if (!profile.length) {
            await createProfile(interaction.user, guild);
          }
          const users = await bot.guilds.cache.get(guild.id);
          const member = await users.members.cache.get(e.id);

          if (member.roles.cache.find((e) => e.id === '969414258116923392')) {
            await Profile.updateOne(
              { UserID: e.id, GuildID: guild.id },
              { $inc: { Wallet: Number(reward.holder.voteReward) } }
            );
            if (e.bluechipChoice === bluechipRank3[0].name) {
              await Profile.updateOne(
                { UserID: e.id, GuildID: guild.id },
                { $inc: { Wallet: Number(reward.holder.Rank1Reward) } }
              );
            }
            // if (e.bluechipChoice === bluechipRank3[1].name) {
            // }
            // if (e.bluechipChoice === bluechipRank3[2].name) {
            // }

            if (e.risingChoice === risingRank3[0].name) {
              await Profile.updateOne(
                { UserID: e.id, GuildID: guild.id },
                { $inc: { Wallet: Number(reward.holder.Rank1Reward) } }
              );
            }
            // if (e.risingChoice === risingRank3[1].name) {
            // }
            // if (e.risingChoice === risingRank3[2].name) {
            // }
          } else {
            await Profile.updateOne(
              { UserID: e.id, GuildID: guild.id },
              { $inc: { Wallet: Number(reward.general.voteReward) } }
            );
          }
        });
        db.get('voteRewarded').assign(voteId).write();
      }
    }

    ////////////select Ìà¨Ìëú Ï≤òÎ¶¨//////////////////////
    collector.on('collect', async (interaction) => {
      // Î∞∞Ïó¥(buttons array)Ïóê ÏûàÎäî ÎèôÏûëÏùÑ ÏûêÎèôÏúºÎ°ú ÏùΩÏùå
      if (
        interaction.isSelectMenu() &&
        (interaction.customId === 'selectBluechip' ||
          interaction.customId === 'selectRising')
      ) {
        const voteId = db.get('voteStatus').value().voteId;

        let profile = await Profile.find({
          UserID: interaction.user.id,
          GuildID: guild.id,
        });
        const users = await bot.guilds.cache.get(guild.id);
        const member = await users.members.cache.get(interaction.user.id);
        let voteReward;
        if (
          member.roles.cache.find(
            (e) => interaction.user.id === '969414258116923392'
          )
        ) {
          voteReward = reward.holder.voteReward;
        } else {
          voteReward = reward.general.voteReward;
        }
        //Í≥ÑÏ¢å ÏóÜÏúºÎ©¥ Í∞úÏÑ§
        if (!profile.length) {
          await createProfile(interaction.user, guild);
        }

        if (
          !db
            .get('voteUser')
            .find({ id: interaction.user.id, voteId: voteId })
            .value()
        ) {
          db.get('voteUser')
            .push({
              voteId: voteId,
              id: interaction.user.id,
              userName: interaction.user.username,
              bluechipChoice: '',
              risingChoice: '',
            })
            .write();
          await Profile.updateOne(
            { UserID: interaction.user.id, GuildID: guild.id },
            { $inc: { Wallet: Number(voteReward) } }
          );
        }

        await interaction.reply({
          embeds: [
            new MessageEmbed()
              .setColor('BLURPLE')
              .setTitle(`${interaction.user.username}'s Earning`)
              .setDescription(
                `You will have collected Voting Participation Rewards (${voteReward}SBT).\n
                  ${interaction.values[0]}Ïóê Ìà¨ÌëúÌïòÏÖ®ÏäµÎãàÎã§.`
              ),
          ],
          ephemeral: true,
        });

        if (interaction.customId === 'selectBluechip') {
          db.get('voteUser')
            .find({ id: interaction.user.id, voteId: voteId })
            .assign({
              voteId: voteId,
              id: interaction.user.id,
              userName: interaction.user.username,
              bluechipChoice: interaction.values[0],
            })
            .write();
        } else if (interaction.customId === 'selectRising') {
          db.get('voteUser')
            .find({ id: interaction.user.id, voteId: voteId })
            .assign({
              voteId: voteId,
              id: interaction.user.id,
              userName: interaction.user.username,
              risingChoice: interaction.values[0],
            })
            .write();
        }

        return;
      }
      if (interaction.isButton()) {
        if (interaction.customId === 'bluechipButton') {
          const bluechipList = db.get('bluechipList').value();

          const selectBluechipNFTRow = new MessageActionRow().addComponents(
            new MessageSelectMenu()
              .setCustomId('selectBluechip')
              .setPlaceholder('select Bluechip NFT')
              .addOptions(
                bluechipList.map((e) => ({
                  label: e.name,
                  description: e.name,
                  value: e.name,
                }))
              )
          );

          await interaction.reply({
            components: [selectBluechipNFTRow],
            ephemeral: true,
          });
        } else if (interaction.customId === 'risingButton') {
          const risingList = db.get('risingList').value();
          const selectRisingNFTRow = new MessageActionRow().addComponents(
            new MessageSelectMenu()
              .setCustomId('selectRising')
              .setPlaceholder('select Rising NFT')
              .addOptions(
                risingList.map((e) => ({
                  label: e.name,
                  description: e.name,
                  value: e.name,
                  address: e.id,
                }))
              )
          );
          await interaction.reply({
            components: [selectRisingNFTRow],
            ephemeral: true,
          });
        }
      }
    });
    // Î≤ÑÌäº Ïù¥Î≤§Ìä∏ Ï¢ÖÎ£å (Ïó¨Í∏∞ÏóêÏÑúÎäî ÏãúÍ∞ÑÏ¥àÍ≥º)Í∞Ä ÎêêÏùÑÎïå, Î≠ò Ìï†ÏßÄ Ï†ïÏùò
    collector.on('end', async (collect) => {});
  },
};
